/*
 *
 * Confidential Information of Telekinesys Research Limited (t/a Havok). Not for disclosure or distribution without Havok's
 * prior written consent. This software contains code, techniques and know-how which is confidential and proprietary to Havok.
 * Product and Trade Secret source code contains trade secrets of Havok. Havok Software (C) Copyright 1999-2013 Telekinesys Research Limited t/a Havok. All Rights Reserved. Use of this software is subject to the terms of an end user license agreement.
 *
 */

#ifndef HKB_NODE_INFO_H
#define HKB_NODE_INFO_H

class hkbNode;
class hkbBehaviorGraph;

	/// Stores returned info about a child of a node.
struct hkbNodeChildInfo
{
	HK_DECLARE_NONVIRTUAL_CLASS_ALLOCATOR( HK_MEMORY_CLASS_BEHAVIOR, hkbNodeChildInfo );

	hkbNodeChildInfo()
		:	m_node(HK_NULL),
			m_nodeClone(HK_NULL),
			m_ignoreEvents(false),
			m_reset(false),
			m_syncToParent(false),
			m_stopped(false)
	{
	}

		/// The child node template.
	hkbNode* m_node; 

		/// The child node clone.
	hkbNode* m_nodeClone;

		/// If true, events will not be sent to the nodes and events generated by the node will
		/// not be forwarded.
	hkBool m_ignoreEvents;

		/// Whether to reset the node asap (deactivate and then activate).
	hkBool m_reset;

		/// Whether or not to synchronize this node with the parent.
	hkBool m_syncToParent;

		/// Whether or not the parent wants this child to be moved forward in time.
	hkBool m_stopped;
};

/// Information about a node in a behavior graph.
struct hkbNodeInfo
{
	HK_DECLARE_NONVIRTUAL_CLASS_ALLOCATOR( HK_MEMORY_CLASS_BEHAVIOR, hkbNodeInfo );

	hkbNodeInfo( hkbNode* nodeClone )
	{
		m_nodeTemplate = HK_NULL;
		m_nodeClone = nodeClone;
		m_behavior = HK_NULL;
		m_rootwardmostParentClone = HK_NULL;
		m_parentClone = HK_NULL;
		m_index = -1;
		m_numParents = 0;
		m_countParents = 0;
		m_flags = FLAG_NONE;
	}

	/// The node template (pre-clone).
	HK_ALIGN16(hkbNode* m_nodeTemplate);

	/// The clone of m_nodeTemplate for this node.
	hkbNode* m_nodeClone;

	/// The behavior that this node is inside.
	hkbBehaviorGraph* m_behavior;

	/// The rootwardmost parent of the node.
	hkbNode* m_rootwardmostParentClone;

	/// This parent is used for computing the timestep of this node based on synchronization or speed.
	hkbNode* m_parentClone;

	/// The currently active children.
	hkArray<hkbNodeChildInfo> m_activeChildren;

	/// The index of this node in the master list of active nodes (hkbBehaviorGraph::m_activeNodes).
	hkInt16 m_index;

	/// The number of parents of the node.
	hkUint8 m_numParents;

	/// This is used during generate() to count down the number of remaining parents so we know
	/// when this node's output is no longer needed.
	hkUint8 m_countParents;

	enum Flags
	{
		FLAG_NONE = 0,

		/// If true, events will not be sent to the nodes and events generated by the node will not be forwarded.
		FLAG_IGNORE_EVENTS = 1,

		/// Whether the node is a generator or a modifier.
		FLAG_IS_GENERATOR = 1<<1,

		/// Whether or not to sync this node to the parent.
		FLAG_SYNC_TO_PARENT = 1<<2,

		/// True if ALL parents want this node to not progress in time.
		FLAG_STOPPED = 1<<3,

		/// Whether activate() has been called on the node or not.
		FLAG_HAS_ACTIVATE_BEEN_CALLED = 1<<4,

		/// This is used during traversals to avoid traversing the same node twice.
		/// It must be reset to false after any traversal that changes it to true.
		FLAG_TOUCHED = 1<<5,

		/// Modifiers are activated preemptively and then this flag is used to keep track of 
		/// when changes to m_enable have been noticed.
		FLAG_IS_MODIFIER_ENABLED = 1<<6,
	};

	hkFlags<Flags, hkInt8> m_flags;

	bool ignoreEvents() const { return m_flags.anyIsSet(FLAG_IGNORE_EVENTS); }
	void setIgnoreEvents() { m_flags.orWith(FLAG_IGNORE_EVENTS); }
	void clearIgnoreEvents() { m_flags.andWith(~FLAG_IGNORE_EVENTS); }
	void assignIgnoreEvents( bool _ignoreEvents ) { m_flags.setWithMask( (hkInt8)( (~((hkUint32)_ignoreEvents - 1)) & FLAG_IGNORE_EVENTS), FLAG_IGNORE_EVENTS ); }

	bool isGenerator() const { return m_flags.anyIsSet(FLAG_IS_GENERATOR); }
	void assignIsGenerator( bool _isGenerator ) { m_flags.setWithMask( (hkInt8)( (~((hkUint32)_isGenerator - 1)) & FLAG_IS_GENERATOR), FLAG_IS_GENERATOR ); }

	bool syncToParent() const { return m_flags.anyIsSet(FLAG_SYNC_TO_PARENT); }
	void setSyncToParent() { m_flags.orWith(FLAG_SYNC_TO_PARENT); }
	void clearSyncToParent() { m_flags.andWith(~FLAG_SYNC_TO_PARENT); }

	bool stopped() const { return m_flags.anyIsSet(FLAG_STOPPED); }
	void setStopped() { m_flags.orWith(FLAG_STOPPED); }
	void clearStopped() { m_flags.andWith(~FLAG_STOPPED); }
	void assignStopped( bool _stopped ) { m_flags.setWithMask( (hkInt8)( (~((hkUint32)_stopped - 1)) & FLAG_STOPPED), FLAG_STOPPED ); }

	bool hasActivateBeenCalled() const { return m_flags.anyIsSet(FLAG_HAS_ACTIVATE_BEEN_CALLED); }
	void setHasActivateBeenCalled() { m_flags.orWith(FLAG_HAS_ACTIVATE_BEEN_CALLED); }
	void clearHasActivateBeenCalled() { m_flags.andWith(~FLAG_HAS_ACTIVATE_BEEN_CALLED); }
	void assignHasActivateBeenCalled( bool _hasActivateBeenCalled ) { m_flags.setWithMask( (hkInt8)( (~((hkUint32)_hasActivateBeenCalled - 1)) & FLAG_HAS_ACTIVATE_BEEN_CALLED), FLAG_HAS_ACTIVATE_BEEN_CALLED ); }

	bool touched() const { return m_flags.anyIsSet(FLAG_TOUCHED); }
	void setTouched() { m_flags.orWith(FLAG_TOUCHED); }
	void clearTouched() { m_flags.andWith(~FLAG_TOUCHED); }

	bool isModifierEnabled() const { return m_flags.anyIsSet(FLAG_IS_MODIFIER_ENABLED); }
	void setIsModifierEnabled() { m_flags.orWith(FLAG_IS_MODIFIER_ENABLED); }
	void clearIsModifierEnabled() { m_flags.andWith(~FLAG_IS_MODIFIER_ENABLED); }
	void assignIsModifierEnabled( bool b ) { m_flags.setWithMask( (hkInt8)( (~((hkUint32)b - 1)) & FLAG_IS_MODIFIER_ENABLED), FLAG_IS_MODIFIER_ENABLED ); }

	// The FLAG_HAS_ACTIVATE_BEEN_CALLED flag is used to support the combination of three features:
	//
	//  1) Only updating the active node list when necessary.
	//  2) The flag hkbModifier::m_enable.
	//  3) The shallow cloning system.
	//
	// When using shallow cloning, only "active nodes" are allocated in memory.  But hkbModifier::m_enable
	// may be bound to a behavior variable, in which case we need to respond to changes in the variable
	// by activating and deactivating the modifier.  However, we can't sync the behavior variables to node
	// properties (eg, m_enable) if the node is not even in memory.
	//
	// We address this problem by including a (cloned) modifier in the active node list if any parent 
	// node reports it to be active, independent of whether or not the node's m_enable is true or false.
	// The modifier is then available for its m_enable to be synced with any bound behavior variable.
	// But this introduces the problem that a modifier in the active node list may not be "really" active
	// (eg, m_enable is false).  If a modifier has m_enable == false then we don't want to activate it.
	// The above flag m_hasActivateBeenCalled is used to distinguish between nodes in the active nodes list
	// that have had their activate() function called (because m_enable is true) and those that have not
	// (because m_enable is false).
	//
	// Note that while a modifier is included in the active node list if and only if any parent node
	// reports it to be active, modifier containers (eg, hkbModifierList, hkbDelayedModifier),
	// do not report any of their children to be active if the container has m_enable == false.  This 
	// ensures that disabling a modifier container disables all of its descendants.
	//
	// In order to support feature (1) above, we monitor changes to m_enable in those modifiers that are
	// in the active node list (and they are guaranteed the be the only relevant ones because any modifier
	// that is not in the active nodes list is inactive because no parent wants it active, not because its
	// m_enable is false).  If a node's m_enable changes, we force the active node list to be refreshed by
	// calling hkbBehaviorGraph::requestUpdateActiveNodes().  See hkbModifierUtils.
};

#endif

/*
 * Havok SDK - Base file, BUILD(#20131218)
 * 
 * Confidential Information of Havok.  (C) Copyright 1999-2013
 * Telekinesys Research Limited t/a Havok. All Rights Reserved. The Havok
 * Logo, and the Havok buzzsaw logo are trademarks of Havok.  Title, ownership
 * rights, and intellectual property rights in the Havok software remain in
 * Havok and/or its suppliers.
 * 
 * Use of this software for evaluation purposes is subject to and indicates
 * acceptance of the End User licence Agreement for this product. A copy of
 * the license is included with this software and is also available from salesteam@havok.com.
 * 
 */
